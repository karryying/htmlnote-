# 移动端浏览器及内核
    UC浏览器、QQ浏览器、百度浏览器、夸克浏览器、360浏览器...
    safari、chrome...
    - 内核：webkit
# viewport
- 视口
    - PC端视口：浏览器显示内容的屏幕区域
    - 移动端视口：分类：布局视口、视觉视口、理想视口
- 分类：
    布局视口：移动端设备默认的viewport(宽度768~1024px)
    视觉视口：可以观看区域，屏幕宽度
    理想视口：为了网站的移动端能更好的浏览和阅读
- meta标签
    - 目的：布局视口和理想视口的宽度保持一致。设备有多宽，布局视口就有多宽
    ```
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
        创建一个虚拟窗口，窗口的宽度为设备宽，初始缩放为1倍，同时不允许用户手动缩放
    ```
    - content属性
        - width 虚拟窗口的宽度        device-width 设备宽
        - initial-scale 初始缩放比
        - user-scalable 是否允许用户手动缩放
            - user-scalable=yes 允许用户手动缩放 默认值
            - user-scalable=no 不允许用户手动缩放
        - maximum-scale 最大缩放比
        - minimum-scale 最小缩放比
# 移动端web页面适配方案   
## 1、固定布局
    设置viewport，布局与PC端一致，假设整个网页的宽度为320px居中，超出部分留白。
- 优点：思路沿用PC端，上手容易
- 缺点：大屏幕手机及手机横屏的时候，左右两侧留有大片留白，并且大屏幕手机下显示内容看起来较小，操作按钮较小，用户体验较差
## 2、流式布局
    宽度使用百分比代替固定宽度px，高度大多用px固定，因此在大屏幕手机下显示效果会变成页面元素宽度被拉长，高度和原来保持一致
- 优点：可以很好解决自适应问题
- 缺点：实际显示效果不协调；大量使用百分比布局，会出现兼容问题；设计有局限性
## 3、响应式布局
    一个网站适配所有终端，实现不同屏幕分辨率下的终端网页的不同布局；使用媒体查询针对不同宽度的设备进行布局和样式设置，从而达到适配不同设备的目的
- 优点：一站适配所有终端、减少工作量；缩短开发周期；对搜索引擎表现更友好；在每个设备中都能得到较好的设计
- 缺点：在老版本的浏览器兼容性不好；兼容各种设备工作量大，效率较低；加载更多的样式和脚本文件；设计比较难于精确定位和控制；是一种折中性质的设计方案，在一定程度上改变网页布局结构，会出现用户混淆情况；维护困难
## 4、rem布局
    rem是css3新增单位，相对于根元素的字号大小而言，如：html{ font-size: 100px; } 一个div标签的宽度为1rem,div的宽度是100px
- rem布局的实现
    - 1）设置页面的viewport
    - 2）动态计算并设置html的font-size属性值
    - 3）按照PC端布局方式正常布局，将px单位改为rem单位；如果值较小（1px），不用转换
- 优点：适用于偏APP类型的移动端页面；有利于手机端各种机型的适配；减少代码重复性；有统一的参考值
- 缺点：使用具有局限性，所有的图片都需要设置一个准确值，才能保证在不同机型的适配中正常显示；必须通过js动态控制根元素的大小
## 5、vw布局
    使用纯css实现动态改变font-size属性值，不需要引用js文件
- vw  viewport‘s width  是css3规范中的宽度视口单位，将视口宽度平均分成100份  720px    7.2
- vh  viewport’s height     高度视口单位，将视口高度平均分成100份
- 1vw = 屏幕宽度的1%
- vmax 相对于视口的宽度或高度中较大的那个值，将最大的那个值平均分成100单位的vmax
- vmin 相对于视口的宽度或高度中较小的那个值，将最小的那个值平均分成100单位的vmin
    - iphone 414px 1vw = 4.14  24.1545 个vw是100px
    - 375px 1vw = 3.75    26.6666个vw是100px
- 原理：确定基准值以常见的750像素宽度的设计稿为例，根据vw单位的原理100vw = 750px，即1vw = 7.5px，根据设计稿中的px值，转换成对应的vw值进行布局，也可以直接写px，后期借助插件完成自动计算得到需要的vw
- 优点：页面元素随着页面宽度变化
- 缺点：兼容性没有ren好
### vw + rem布局
    确定基准值以常见的750px宽度的设计稿为例，根据vw单位和rem单位原理实现在750px设计稿下，如果使用vw单位换算，100vw = 750px，1px = 0.133333vw(100/750)；如果使用rem单位换算，预设1rem = 100px，则100px = 13.3333vw
        html{
            font-size: 13.3333vw;
        }

# 移动端样式重置
## 1、normalize.css 代替样式重置文件
    没有重置所有的样式风格，提供了一套合理的默认样式值
## 2、reset.css样式重置
- 禁止用户选中文字  安卓无效
```
-webkit-user-select: none; 
```
- 禁止长按页面显示系统菜单
```
img,a{
    -webkit-touch-callout: none;
}
```
- 修改placeholder的样式
```
inuput::-webkit-input-placeholder{
    color: #333; /*默认样式*/
}
input:focus::-webkit-input-placeholder{
    color: #f00; /*获取焦点后的样式*/
}
```
# 移动端布局注意：
- 页面布局文字是否能够随着屏幕大小变化而变化
- 流式布局和flex布局主要针对宽度设置布局
- 当屏幕发生改变时，元素的宽度和高度如何等比例缩放

# 移动特殊处理
## 1、超小字号处理（小于12px）
```
transform: scale(.7);
```
## 2、动画定义3d启动硬件加速，提升网站动画渲染性能
    GPU 图形处理器，处理计算机中跟图形计算有关的工作，将数据更好地呈现在显示器中
    CPU 中央处理器，控制计算机运行
```
transform: translate3d(0,0,0)
```
## 3、圆角BUG
```
background-clip:padding-box;
```
## 4、input的placeholder属性会出现文本在偏上位置显示的问题
```
在保证input输入文本垂直居中的条件下，给placeholder设置padding-top,不设置行高
```

SyntaxError  语法错误

# 像素
- 是web开发中常用单位，是组成数字图像的基本单元
- 分类：设备像素、设备独立像素、css像素
## 1、设备像素
- 物理像素：设备固有属性
- 物理像素点：屏幕显示最小的颗粒，是真实存在
- 对应设备分辨率：显示器的宽度和高度分别有多少个物理像素
## 2、设备独立像素
- 逻辑像素、独立像素：操作系统定义的像素单位
- 普遍规律：屏幕的像素密度越高，需要更多的物理像素来显示一个逻辑像素
- 对应逻辑分辨率：使用屏幕的宽*高来表示
### 物理像素和逻辑像素之间的关系
    设备像素比 = 物理像素/逻辑像素
## 3、css像素
- css中使用的像素，当缩放页面时，元素的css像素的数量不变，但是每个像素的大小会变化
    元素width: 100px; 缩放到200%后，宽度是100个css像素，每个css像素的宽、高是原来的两倍
### css像素和逻辑像素之间的关系
    缩放比例 = css像素的边长/逻辑像素的边长
    元素的宽度为100个逻辑像素，缩放到200%后，元素的宽度变为200个逻辑像素
    在缩放比例为100的情况下，一个css像素 = 一个逻辑像素
### css像素和物理之间的关系
    设备像素比：本质是一个css像素表示多少个物理像素

# 视网膜屏Retina
    将更多的像素点压缩在一块屏幕中，达到更高的分辨率，并调高屏幕显示的细腻程度
    普通屏幕 1个css像素对应1个物理像素
    Retina屏 1个css像素对应4个物理像素
- 1像素边框问题
    border-width: thin; 细边框
    border-width: medium; 中等粗度边框
    border-width: thick; 粗边框